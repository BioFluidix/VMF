package ${type.readOnlyImplementation.packageName};

// vmf imports
import ${VMF_RUNTIME_API_PKG}.${VMF_CORE_PKG_EXT}.*;
import ${VMF_RUNTIME_API_PKG}.${VMF_CORE_PKG_EXT}.internal.*;
import ${VCOLL_PKG}.*;
import ${type.packageName}.*;
import java.beans.PropertyChangeListener;

// property types imports
#foreach( $import in $type.implementation.imports )
import $import;
#end

// interface

/**
 * An read-only representation of the model object {@code $type.fullTypeName}.
 */
@SuppressWarnings("deprecation")
class $type.readOnlyImplementation.typeName implements $type.readOnlyInterface.typeName, VObjectInternal, VCloneableInternal {

  private final $type.typeName mutableObject;

  // Read-only view for collection properties
  // - properties with collection type (model & non-model collections)
  // - we don't allow/provide setters for collection properties
#foreach( $prop in $type.implementation.properties )
#if($prop.propType == "COLLECTION")
#if($prop.genericType)
  private VList<${prop.genericType.readOnlyInterface.fullTypeName}> ${prop.name};
#else
  private VList<${prop.genericPackageName}.${prop.genericTypeName}> ${prop.name};
#end ## if genericType
#end ## if collection
#end ## for each property

  public ${type.readOnlyImplementation.typeName}($type.typeName mutableObject) {
    this.mutableObject = mutableObject;
  }

#foreach( $prop in $type.implementation.properties )

  @Override
#if($prop.propType == "COLLECTION")
#if($prop.genericType)
  // generic type is a model-type
  public VList<${prop.genericType.readOnlyInterface.fullTypeName}> ${prop.getterPrefix}${prop.nameWithUpperCase}() {

    // we return an unmodifiable mapped list that contains read-only versions of the list elements
    // since read-only types and normal types are incompatible by design, we specify the lambda
    // operation that converts an element into a read-only version of that element
    if(this.${prop.name} == null) {
      this.${prop.name} = VMappedList.newUnmodifiableInstance(mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}(), (e)->e.asReadOnly());
    }

    return this.${prop.name};

#else
  public VList<${prop.genericPackageName}.${prop.genericTypeName}> ${prop.getterPrefix}${prop.nameWithUpperCase}() {

    if(this.${prop.name} == null) {
      this.${prop.name} = this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}();
    }

    return this.${prop.name};
#end ## if generic type

#elseif(${prop.type})
#if($prop.type.immutable)
  // property type is a model-type
  public $prop.type.typeName ${prop.getterPrefix}${prop.nameWithUpperCase}() {
    if(this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}()!=null) {
      return this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}();
    } else {
      return null;
    }
#else## if prop type is immutable
  // property type is a model-type
  public $prop.type.readOnlyInterface.typeName ${prop.getterPrefix}${prop.nameWithUpperCase}() {
    if(this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}()!=null) {
      return this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}().asReadOnly();
    } else {
      return null;
    }
#end## if prop type is immutable
#else
  public $prop.typeName ${prop.getterPrefix}${prop.nameWithUpperCase}() {
    return this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}();
#end
  }

#end // end for each property

  @Override
  public void addPropertyChangeListener(PropertyChangeListener l) {
    ((VObjectInternal)this.mutableObject).addPropertyChangeListener(l);
  }

  @Override
  public void removePropertyChangeListener(PropertyChangeListener l) {
    ((VObjectInternal)this.mutableObject).removePropertyChangeListener(l);
  }

  @Override
  public String toString() {
    return this.mutableObject.toString();
  }

  @Override
  public boolean equals(Object o) {
    return this.mutableObject.equals(o);
  }

  @Override
  public int hashCode() {
    return this.mutableObject.hashCode();
  }

  @Override
  public $type.typeName _vmf_getMutableObject() {
    return this.mutableObject;
  }

  @Override
  public $type.readOnlyImplementation.typeName asReadOnly() {
    return this;
  }

  // --------------------------------------------------------------------
  // --- Cloning
  // --------------------------------------------------------------------

  @Override
  public ${type.readOnlyInterface.typeName} clone() {
    return this.mutableObject.clone().asReadOnly();
  }

  @Override
  public ${type.typeName} asModifiable() {
    return this.mutableObject.clone();
  }

  @Override
  public ${type.typeName} _vmf_deepCopy(
    java.util.IdentityHashMap<Object,Object> identityMap) {
    return (${type.typeName})
      ((VCloneableInternal)this.mutableObject)._vmf_deepCopy(
        new java.util.IdentityHashMap<>());
  }

  @Override
  public ${type.readOnlyInterface.typeName} _vmf_shallowCopy(
    java.util.IdentityHashMap<Object,Object> identityMap) {
    return (${type.readOnlyInterface.typeName})
      ((VCloneableInternal)this.mutableObject)._vmf_shallowCopy(
        new java.util.IdentityHashMap<>()).asReadOnly();
  }

  // --------------------------------------------------------------------
  // --- Public VMF API
  // --------------------------------------------------------------------

  @Override
  public VMF vmf() {
    return new VMF() {
      public Content content() {
        return new Content() {
          public java.util.Iterator<VObject> iterator() {
            return VIterator.of(${type.readOnlyImplementation.typeName}.this);
          }
          public java.util.stream.Stream<VObject> stream() {
            return VIterator.of(${type.readOnlyImplementation.typeName}.this).asStream();
          }

          public java.util.Iterator<VObject> iterator(VIterator.IterationStrategy strategy) {
            return VIterator.of(${type.readOnlyImplementation.typeName}.this, strategy);
          }
          public java.util.stream.Stream<VObject> stream(VIterator.IterationStrategy strategy) {
            return VIterator.of(${type.readOnlyImplementation.typeName}.this, strategy).asStream();
          }

          @Override
          public ${type.readOnlyInterface.typeName} deepCopy() {
            return (${type.readOnlyImplementation.typeName})
              ((VCloneableInternal)${type.readOnlyImplementation.typeName}.this.mutableObject)._vmf_deepCopy(
                new java.util.IdentityHashMap<>()).asReadOnly();
          }

          @Override
          public ${type.readOnlyInterface.typeName} shallowCopy() {
            return ${type.readOnlyImplementation.typeName}.
              this._vmf_shallowCopy(new java.util.IdentityHashMap<>());
          }
        };
      }

    }; // end vmf
  }


  // --------------------------------------------------------------------
  // --- Reflection methods
  // --------------------------------------------------------------------

  // type id for improved reflection performance
  public static final int _VMF_TYPE_ID = $type.readOnlyImplementation.typeId;

  @Override
  public int _vmf_getTypeId() {
    return _VMF_TYPE_ID;
  }

#set($readOnlyVal=true)
#parse("${VMF_TEMPLATE_PATH}reflection/reflection.vm")

  @Override
  public boolean _vmf_isReadOnly() {
    return true;
  }

  // --------------------------------------------------------------------
  // --- Id related methods
  // --------------------------------------------------------------------

  // id management is currently not part of VMF (TODO how should we support this?)

  // --------------------------------------------------------------------
  // --- Reference methods
  // --------------------------------------------------------------------

  public java.util.List<VObject> _vmf_referencedBy() { return  ((VObjectInternalModifiable)this.mutableObject)._vmf_referencedBy();}

  public java.util.List<VObject> _vmf_references() { return  ((VObjectInternalModifiable)this.mutableObject)._vmf_references();}
}
