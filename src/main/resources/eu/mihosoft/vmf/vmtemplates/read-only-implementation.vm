package ${type.readOnlyImplementation.packageName};

// vmf imports
import ${VMF_CORE_API_PKG}.${VMF_VMFUTIL_PKG_EXT}.*;
import ${VCOLL_PKG}.*;
import ${type.packageName}.*;
import java.beans.PropertyChangeListener;

// property types imports
#foreach( $import in $type.implementation.imports )
import $import;
#end

// interface

/**
 * An immutable representation of the model object {@code $type.fullTypeName}.
 */
class $type.readOnlyImplementation.typeName implements $type.readOnlyInterface.typeName, VObjectInternal {

  private final $type.typeName mutableObject;

// Read-only view for collection properties
// - properties with collection type (model & non-model collections)
// - we don't allow/provide setters for collection properties
#foreach( $prop in $type.implementation.properties )
#if($prop.propType == "COLLECTION")
#if($prop.genericType)
  private VList<${prop.genericType.readOnlyInterface.fullTypeName}> ${prop.name};
#else
  private VList<${prop.genericPackageName}.${prop.genericTypeName}> ${prop.name};
#end ## if genericType
#end ## if collection
#end ## for each property

  public ${type.readOnlyImplementation.typeName}($type.typeName mutableObject) {
    this.mutableObject = mutableObject;
  }

#foreach( $prop in $type.implementation.properties )

  @Override
#if($prop.propType == "COLLECTION")
#if($prop.genericType)
  // generic type is a model-type
  public VList<${prop.genericType.readOnlyInterface.fullTypeName}> ${prop.getterPrefix}${prop.nameWithUpperCase}() {

    // we return an unmodifiable mapped list that contains read-only versions of the list elements
    // since read-only types and normal types are incompatible by design, we specify the lambda
    // operation that converts an element into a read-only version of that element
    if(this.${prop.name} == null) {
      this.${prop.name} = VMappedList.newUnmodifiableInstance(mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}(), (e)->e.asReadOnly());
    }

    return this.${prop.name};

#else
  public VList<${prop.genericPackageName}.${prop.genericTypeName}> ${prop.getterPrefix}${prop.nameWithUpperCase}() {

    if(this.${prop.name} == null) {
      this.${prop.name} = this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}();
    }

    return this.${prop.name};
#end ## if generic type

#elseif(${prop.type})
  // property type is a model-type
  public $prop.type.readOnlyInterface.typeName ${prop.getterPrefix}${prop.nameWithUpperCase}() {
    if(this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}()!=null) {
      return this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}().asReadOnly();
    } else {
      return null;
    }
#else
  public $prop.typeName ${prop.getterPrefix}${prop.nameWithUpperCase}() {
    return this.mutableObject.${prop.getterPrefix}${prop.nameWithUpperCase}();
#end
  }

#end // end for each property

  @Override
  public void addPropertyChangeListener(PropertyChangeListener l) {
    this.mutableObject.addPropertyChangeListener(l);
  }

  @Override
  public void removePropertyChangeListener(PropertyChangeListener l) {
    this.mutableObject.removePropertyChangeListener(l);
  }

  @Override
  public String toString() {
    return this.mutableObject.toString();
  }

  @Override
  public boolean equals(Object o) {
    return this.mutableObject.equals(o);
  }

  @Override
  public int hashCode() {
    return this.mutableObject.hashCode();
  }

  $type.typeName _vmf_getMutableObject() {
    return this.mutableObject;
  }


  // --------------------------------------------------------------------
  // --- Reflection methods
  // --------------------------------------------------------------------

  // type id for improved reflection performance
  public static final int _VMF_TYPE_ID = $type.readOnlyImplementation.typeId;

  @Override
  public int _vmf_getTypeId() {
    return _VMF_TYPE_ID;
  }

#parse("${VMF_TEMPLATE_PATH}reflection/reflection.vm")

}
