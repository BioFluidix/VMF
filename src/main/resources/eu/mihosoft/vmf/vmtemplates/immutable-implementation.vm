#*
 * Copyright 2016-2017 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 *#
package ${type.implementation.packageName};

// vmf imports
import ${VMF_RUNTIME_API_PKG}.${VMF_CORE_PKG_EXT}.*;
import ${VMF_RUNTIME_API_PKG}.${VMF_CORE_PKG_EXT}.internal.*;
import ${VCOLL_PKG}.*;
import ${type.packageName}.*;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyChangeListener;
import java.util.Objects;
import java.util.Arrays;

// property types imports
#foreach( $import in $type.implementation.imports )
import $import;
#end

// implementation

/**
 * An implementation of the immutable model object {@code $type.fullTypeName}.
 */
@SuppressWarnings("deprecation")
public class $type.implementation.typeName implements $type.typeName, VObject, VObjectInternal, VCloneableInternal {

  // --------------------------------------------------------------------
  // --- declaration of member variables
  // --------------------------------------------------------------------

#parse("${VMF_TEMPLATE_PATH}impl/declare-props.vm")

#parse("${VMF_TEMPLATE_PATH}impl/declare-delegates.vm")

  // referenced by
  private final VList<VObject> referencedBy = VList.newInstance(new java.util.ArrayList<>());
  // references
  private final VList<VObject> references = VList.newInstance(new java.util.ArrayList<>());

  // --------------------------------------------------------------------
  // --- private constructor
  // --------------------------------------------------------------------

  private ${type.implementation.typeName}() {
    // ...
  }

  // --------------------------------------------------------------------
  // --- public getter methods for accessing properties
  // --------------------------------------------------------------------

##parse("${VMF_TEMPLATE_PATH}impl/getter.vm")
#foreach( $prop in ${type.implementation.properties} )
  @Override
  public $prop.getterDeclaration {
    return this.${prop.name};
  }
#end##foreach property

  // --------------------------------------------------------------------
  // --- Object methods (equals(), toString() etc.)
  // --------------------------------------------------------------------

#parse("${VMF_TEMPLATE_PATH}impl/to-string.vm")

#parse("${VMF_TEMPLATE_PATH}impl/equals.vm")

  public $type.typeName clone() {
    // we don't need to perform actual cloning since this is an
    // immutable type
    return this;
  }

#parse("${VMF_TEMPLATE_PATH}impl/builder.vm")

#parse("${VMF_TEMPLATE_PATH}impl/delegation-methods.vm")

  // --------------------------------------------------------------------
  // --- Utility methods
  // --------------------------------------------------------------------

  @Override
  public void addPropertyChangeListener(PropertyChangeListener l) {
      // don't do anything. immutable types don't publish change events
  }
  @Override
  public void removePropertyChangeListener(PropertyChangeListener l) {
      // don't do anything. immutable types don't publish change events
  }

  private boolean _vmf_hasListeners() {
      return false;
  }

  private void _vmf_firePropertyChangeIfListenersArePresent() {
     // don't do anything. immutable types don't publish change events
  }

  @Override
  public ${type.typeName} _vmf_deepCopy(
    java.util.IdentityHashMap<Object,Object> identityMap) {
    return this;
  }

  @Override
  public ${type.typeName} _vmf_shallowCopy(
    java.util.IdentityHashMap<Object,Object> identityMap) {
    return this;
  }

  // --------------------------------------------------------------------
  // --- Public VMF API
  // --------------------------------------------------------------------

 private VMF vmf;

  @Override
  public VMF vmf() {
    if(vmf==null) {
      vmf = new VMF() {
        public Content content() {
          return new Content() {
            public java.util.Iterator<VObject> iterator() {
              return VIterator.of(${type.implementation.typeName}.this);
            }
            public java.util.stream.Stream<VObject> stream() {
              return VIterator.of(${type.implementation.typeName}.this).asStream();
            }

            public java.util.Iterator<VObject> iterator(VIterator.IterationStrategy strategy) {
              return VIterator.of(${type.implementation.typeName}.this, strategy);
            }
            public java.util.stream.Stream<VObject> stream(VIterator.IterationStrategy strategy) {
              return VIterator.of(${type.implementation.typeName}.this, strategy).asStream();
            }
            public <T extends VObject> java.util.stream.Stream<T> stream(Class<T> type) {
              return stream().filter(e->type.isAssignableFrom(e.getClass())).map(e->(T)e);
            }
            public <T extends VObject> java.util.stream.Stream<T> stream(Class<T> type, VIterator.IterationStrategy strategy) {
              return stream(strategy).filter(e->type.isAssignableFrom(e.getClass())).map(e->(T)e);
            }
            public VList<VObject> referencedBy() {
              return _vmf_referencedBy().asUnmodifiable();
            }
            public VList<VObject> references() {
              return _vmf_references().asUnmodifiable();
            }

            @Override
            public ${type.typeName} deepCopy() {
              java.util.IdentityHashMap<Object,Object> identityMap =
              new java.util.IdentityHashMap<>();
              return _vmf_deepCopy(identityMap);
            }

            @Override
            public ${type.typeName} shallowCopy() {
              // we don't copy anything since this is an immutable type
              return ${type.implementation.typeName}.this;
              }
            };
          }

          private ChangesImpl changes;

          public Changes changes() {
            if (changes==null) {
              changes = new ChangesImpl();
              changes.setModel(${type.implementation.typeName}.this);
            }

            return changes;
          }
        }; // end vmf
      } // end if null

      return vmf;
  }

  @Override
  public ${type.typeName} asReadOnly() {
    return this;
  }

  // --------------------------------------------------------------------
  // --- Reflection methods
  // --------------------------------------------------------------------

  // type id for improved reflection performance
  public static final int _VMF_TYPE_ID = $type.typeId;

  @Override
  public int _vmf_getTypeId() {
    return _VMF_TYPE_ID;
  }

#set($readOnlyVal=true)
#parse("${VMF_TEMPLATE_PATH}reflection/reflection.vm")

  // --------------------------------------------------------------------
  // --- Id related methods
  // --------------------------------------------------------------------

  // id management is currently not part of VMF (TODO how should we support this?)

  // --------------------------------------------------------------------
  // --- Reference methods
  // --------------------------------------------------------------------

  @Override
  public VList<VObject> _vmf_referencedBy() { return this.referencedBy;}
  @Override
  public VList<VObject> _vmf_references() { return this.references;}

}
