package ${type.packageName};

// vmf imports
import ${VMF_RUNTIME_API_PKG}.${VMF_CORE_PKG_EXT}.*;
import ${VCOLL_PKG}.*;

// property types imports
#foreach( $import in $type.imports )
import $import;
#end

// interface

/**
 * An read-only representation of the model object {@code $type.fullTypeName}.
 *
 * <!-- vmf-begin-model-doc -->
 * <!-- vmf-end-model-doc -->
 *
 */
public interface $type.readOnlyInterface.typeName extends VObject$type.readOnlyImplementsString, ReadOnly {
#foreach( $prop in $type.properties )

#if(${prop.containmentInfo.containmentType}=="CONTAINER")
#set($opposite = ${prop.containmentInfo.opposite})
/**
 * Returns the value of the '<em><b>${prop.name}</b></em>' container reference.
 *
 * It is bidirectional and its opposite is '{@link ${opposite.parent.readOnlyInterface.typeName}#${prop.getterPrefix}${opposite.nameWithUpperCase}() <em>${opposite.name}</em>}'.
 *
 * <!-- vmf-begin-model-doc -->
 * <!-- vmf-end-model-doc -->
 *
 * @return the value of the '<em>${prop.name}</em>' container reference.
 * @see ${type.typeName}#set${prop.nameWithUpperCase}($prop.typeName)
 */
#elseif (${prop.containmentInfo.containmentType}=="CONTAINED")
#if(${prop.propType}=="COLLECTION")
#set($opposite = ${prop.containmentInfo.opposite})
  /**
   * Returns the value of the '<em>${prop.name}</em>' containment list.
   *
   * It is bidirectional and its opposite is '{@link ${prop.genericType.readOnlyInterface.typeName}#${prop.getterPrefix}${opposite.nameWithUpperCase}() <em>${opposite.name}</em>}'.
   *
   * <!-- vmf-begin-model-doc -->
   * <!-- vmf-end-model-doc -->
   *
   * @return the value of the '<em>${prop.name}</em>' containment list.
   */
#else ## if collection
#set($opposite = ${prop.containmentInfo.opposite})
  /**
   * Returns the value of the '<em><b>${prop.name}</b></em>' containment reference.
   *
   * It is bidirectional and its opposite is '{@link ${prop.type.readOnlyInterface.typeName}#${prop.getterPrefix}${opposite.nameWithUpperCase}() <em>${opposite.name}</em>}'.
   *
   * <!-- vmf-begin-model-doc -->
   * <!-- vmf-end-model-doc -->
   *
   * @return the value of the '<em><b>${prop.name}</b></em>' containment reference.
   * @see ${type.typeName}#set${prop.nameWithUpperCase}($prop.typeName)
   */
#end ## if collection
#else ## if container / contained
 /**
  * Returns the value of the '<em>${prop.name}</em>' property.
  *
  * <!-- vmf-begin-model-doc -->
  * <!-- vmf-end-model-doc -->
  *
  * @return the value of the '<em>${prop.name}</em>' property.
  * #if(${prop.propType}!="COLLECTION")@see ${type.typeName}#set${prop.nameWithUpperCase}($prop.typeName)
#end
  */
#end ## if container / contained
#if($prop.propType == "COLLECTION")
#if($prop.genericType)
  // generic model type
  public VList<${prop.genericType.readOnlyInterface.fullTypeName}> ${prop.getterPrefix}${prop.nameWithUpperCase}();
#else
  public VList<${prop.genericPackageName}.${prop.genericTypeName}> ${prop.getterPrefix}${prop.nameWithUpperCase}();
#end ## if genericType
#else
  public #if($prop.type)#if($prop.type.immutable)$prop.type.typeName#else$prop.type.readOnlyInterface.typeName#end#else$prop.typeName#end ${prop.getterPrefix}${prop.nameWithUpperCase}();
#end ## if collection

#end ## for each

  /**
   * Returns a deep clone of this object.
   * @return a deep clone of this object
   */
  public ${type.readOnlyInterface.typeName} clone();

  @Override
  default ${type.readOnlyInterface.typeName} asReadOnly() {
    return this;
  }

#if(!${type.isInterfaceOnly()})
  /**
   * Returns a modifiable deep clone of this object.
   * @return a modifiable deep clone of this object
   */
  ${type.typeName} asModifiable();
#end## if type is not interface-only type

}
