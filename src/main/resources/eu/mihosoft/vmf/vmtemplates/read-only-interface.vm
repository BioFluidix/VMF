package ${type.packageName};

// vmf imports
import ${VMF_CORE_API_PKG}.${VMF_VMFUTIL_PKG_EXT}.*;

// property types imports
#foreach( $import in $type.imports )
import $import;
#end

// interface

/**
 * An immutable representation of the model object {@code $type.fullTypeName}.
 */
public interface $type.readOnlyInterface.typeName extends VObject$type.readOnlyImplementsString {
#foreach( $prop in $type.properties )

#if(${prop.containmentInfo.containmentType}=="CONTAINER")
#set($opposite = ${prop.containmentInfo.opposite})
/**
 * Returns the value of the '<em><b>${prop.name}</b></em>' container reference.
 *
 * It is bidirectional and its opposite is '{@link ${opposite.typeName}#get${opposite.nameWithUpperCase}() <em>${opposite.name}</em>}'.
 *
 * <!-- vmf-begin-model-doc -->
 * <!-- vmf-end-model-doc -->
 *
 * @return the value of the '<em><b>Master</b></em>' container reference.
 * @see WritableNode#setMaster(Node)
 */
#elseif (${prop.containmentInfo.containmentType}=="CONTAINED")
#if(${prop.propType}=="COLLECTION")
#set($opposite = ${prop.containmentInfo.opposite})
  /**
   * Returns the value of the '<em>${prop.name}</em>' containment list.
   *
   * It is bidirectional and its opposite is '{@link ${opposite.typeName}#get${opposite.nameWithUpperCase}() <em>${opposite.name}</em>}'.
   *
   * <!-- vmf-begin-model-doc -->
   * <!-- vmf-end-model-doc -->
   *
   * @return the value of the '<em>${prop.name}</em>' containment list.
   */
#else ## if collection
  /**
   * Returns the value of the '<em><b>${prop.name}</b></em>' containment reference.
   *
   * It is bidirectional and its opposite is '{@link ${opposite.typeName}#get${opposite.nameWithUpperCase}() <em>${opposite.name}</em>}'.
   *
   * <!-- vmf-begin-model-doc -->
   * <!-- vmf-end-model-doc -->
   *
   * @return the value of the '<em><b>${prop.name}</b></em>' containment reference.
   * @see  Writable${type.typeName}#set${prop.nameWithUpperCase}($prop.typeName)
   */
#end ## if collection
#else ## if container / contained
 /**
  * Returns the value of the '<em>${prop.name}</em>' property.
  *
  * <!-- vmf-begin-model-doc -->
  * <!-- vmf-end-model-doc -->
  *
  * @return the value of the '<em>${prop.name}</em>' property.
  * @see Writable${type.typeName}#set${prop.nameWithUpperCase}($prop.typeName)
  */
#end ## if container / contained
  public #if($prop.type)$prop.type.readOnlyInterface.typeName#else$prop.typeName#end get${prop.nameWithUpperCase}();

#end ## for each

  /**
   * Creates an read-only wrapper of '{@link ${type.typeName} <em><b>${type.typeName}</b></em>'}
   * @param mutableObject mutable object
   * @return a read-only wrapper of '{@link ${type.typeName} <em><b>${type.typeName}</b></em>'}
   */
  static ${type.readOnlyInterface.typeName} asReadOnly(${type.typeName} mutableObject) {
    try {
      Class<?> cls = Class.forName("${type.readOnlyImplementation.packageName}.${type.readOnlyImplementation.typeName}");
      java.lang.reflect.Constructor constructor = cls.getConstructor(${type.typeName}.class);
      constructor.setAccessible(true);
      return (${type.readOnlyInterface.packageName}.${type.readOnlyInterface.typeName}) constructor.newInstance(mutableObject);
    } catch (ClassNotFoundException ex) {
      java.util.logging.Logger.getLogger(${type.typeName}.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
      java.util.logging.Logger.getLogger(${type.typeName}.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
      java.util.logging.Logger.getLogger(${type.typeName}.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }  catch (NoSuchMethodException ex) {
      java.util.logging.Logger.getLogger(${type.typeName}.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (SecurityException ex) {
      java.util.logging.Logger.getLogger(${type.typeName}.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalArgumentException ex) {
      java.util.logging.Logger.getLogger(${type.typeName}.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (java.lang.reflect.InvocationTargetException ex) {
      java.util.logging.Logger.getLogger(${type.typeName}.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }

    return null;
  }


}
