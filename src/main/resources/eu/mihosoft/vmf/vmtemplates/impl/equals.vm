
  // --------------------------- BEGIN EQUALITY -----------------------------

  @Override
  public boolean equals(Object o) {

  boolean entry = _vmf_fEqualsChecker.get().isEmpty();
    try {
      // test if the object pair (this,o) has been checked before
      if (_vmf_fEqualsChecker.get().containsKey(new EqualsPair(this, o))) {
        // This pair has been seen before. That's why we return true now.
        // If this pair wasn't equal, we wouldn't need to do a second
        // comparison. Returning 'true' is equivalent to ignoring this
        // particular test in the calling 'equals()' method.
        return true;
      } else {
        _vmf_fEqualsChecker.get().put(new EqualsPair(this, o), null);
        entry = true;
      }

      if (o==null) return false;
      else if (this==o) return true;

      // if object is read-only wrapper then unwrap the actual object
      if(o instanceof $type.readOnlyImplementation.typeName) {
        o = (($type.readOnlyImplementation.typeName)o)._vmf_getMutableObject();
      }

      // perform the actual comparison for each property
      if (o instanceof $type.fullTypeName) {
        $type.implementation.typeName other = ($type.implementation.typeName) o;
        return #if($type.implementation.propertiesForEquals.isEmpty())true;#end
#foreach ($prop in $type.implementation.propertiesForEquals)
          _vmf_equals(this.$prop.name, other.$prop.name)#if($foreach.hasNext) &&#else;#end

#end ## for-each property
      }
      else return false;
    } finally {
      if (entry) {
          _vmf_fEqualsChecker.get().clear();
      }
    }
  } // end equals()

  private static boolean _vmf_equals(Object o1, Object o2) {
    boolean oneIsNull = (o1 == null) != (o2 == null);
    boolean collectionType = o1 instanceof VList || o2 instanceof VList;

    // since we support lazy initialization for collections,
    // uninitialized empty collection values are defined as equal to null
    // otherwise we would have to initialize these values, which would then
    // neutralize or even negate the positive effect of lazy initialization
    if(oneIsNull && collectionType) {
      return true;
    } else {
      return Objects.equals(o1,o2);
    }
  }

  @Override
  public int hashCode() {
    return _vmf_deepHashCode(
#foreach ($prop in $type.implementation.propertiesForEquals)
      this.$prop.name#if($foreach.hasNext),#end

#end    );
  } // end hashCode()

  // fixes 'array discovery problems' with the 'Objects.hash(...)' method
  // see http://stackoverflow.com/questions/30385018/how-to-use-java-7-objects-hash-with-arrays
  private int _vmf_deepHashCode(Object... fields) {
    return Arrays.deepHashCode(fields);
  } // end _vmf_deepHashCode()

  /**
   * The purpose of this class is to store a pair of objects used for equals().
   * This class's equals() method checks equality by object identity. Same
   * for hashCode() which uses identity hashes of 'first' and 'second' to
   * compute the hash.
   *
   * This class can be used in conjunction with a regular HashMap to get
   * similar results to a IdentityHashMap, except that in this case identity
   * pairs can be used. And we don't have to use a map implementation that is
   * deliberately broken by design.
   */
  private static class EqualsPair {

      final Object first;
      final Object second;

      public EqualsPair(Object first, Object second) {
          this.first = first;
          this.second = second;
      }

      @Override
      public int hashCode() {
          return Objects.hash(System.identityHashCode(first),
                  System.identityHashCode(second));
      }

      @Override
      public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final EqualsPair other = (EqualsPair) obj;
        if (this.first!=other.first) {
            return false;
        }
        if (this.second!=other.second) {
            return false;
        }
        return true;
      }
  }

  private final ThreadLocal<java.util.HashMap<EqualsPair, ?>> _vmf_fEqualsChecker
          = new ThreadLocal<java.util.HashMap<EqualsPair, ?>>() {
      @Override
      protected java.util.HashMap<EqualsPair, ?> initialValue() {
          return new java.util.HashMap<>();
      }
  };

  // ---------------------------- END EQUALITY ------------------------------
