  // --------------------------- BEGIN TO_STRING -----------------------------
#if(${type.isToStringMethodDelegated()})
  // -> toString() method is delegated
#else## #if(${type.isToStringMethodDelegated()})
  @Override
  public String toString() {

    boolean entry = _vmf_getThreadLocalToString().get().isEmpty();
    try {
        // test if "this" has been seen before
        // implementation based on http://stackoverflow.com/a/11300376/1493549
        boolean isImmutable = (this instanceof eu.mihosoft.vmf.runtime.core.Immutable);
        if (!isImmutable && _vmf_getThreadLocalToString().get().containsKey(this)) {
          return "{skipping recursion}";
        } else {
          if(!isImmutable) {
            _vmf_getThreadLocalToString().get().put(this, null);
          }
          entry = true;
        }
        return "{\"@Type\":\"$type.typeName\"" + 
#foreach ($prop in $type.implementation.properties)
#if ($prop.containmentInfo.containmentType != "CONTAINER" )
#if ($prop.containmentInfo.containmentType == "CONTAINED" && $prop.propType == "COLLECTION")
        ", " + (this.${prop.name}==null?"[]":this.${prop.name}) +
#else
        ", \"$prop.name\": \"" + this.$prop.name + "\"" +
#end ## if contained and collection
#end ## end if container type
#end ## for-each property
        "}";
    } finally {
        if (entry) {
            _vmf_getThreadLocalToString().get().clear();
            _vmf_fToStringChecker = null;
        }
    }
  }

  private ThreadLocal<java.util.IdentityHashMap<$type.typeName, ?>> _vmf_getThreadLocalToString() {
    if (_vmf_fToStringChecker==null) {
      _vmf_fToStringChecker = ThreadLocal.withInitial(
        () -> new java.util.IdentityHashMap<>());
    }

    return _vmf_fToStringChecker;
  }

  private ThreadLocal<java.util.IdentityHashMap<$type.typeName, ?>> _vmf_fToStringChecker;

  // end toString()
#end## #if(${type.isToStringMethodDelegated()})
  // ---------------------------- END TO_STRING ------------------------------
