
  // --------------------------- BEGIN CLONING -----------------------------

  /**Package private copy constructor.
   * It creates a deep or shallow copy of the specified other object.
   * @param other other object
   * @param deepCopy defines whether to perform a deep copy
   */
  ${type.implementation.typeName} (
    ${type.implementation.typeName} other,
    boolean deepCopy, java.util.IdentityHashMap<Object,Object> identityMap
## #foreach ($prop in $type.implementation.properties)
## #if(!$prop.container)
## $prop.typeName $prop.name#if($foreach.hasNext), #end
## #end ## if containment typs
## #end ## for-each property
  ) {
    identityMap.put(other,this);
#foreach ($prop in $type.implementation.properties)
#if(!$prop.container)
#if($prop.propType=="COLLECTION")
    if(deepCopy) {
      if(other.${prop.name}!=null) {
#if($prop.genericType)
        // element type is a model type
        for($prop.genericType.typeName e : other.${prop.name}) {
          // TODO do a bulk operation instead
          this.get${prop.nameWithUpperCase}().add(($prop.genericType.typeName)((VMFInternalInterface)e)._vmf_deepCopy(identityMap));
        }
#else
        // element type is an external type (TODO implement cloning strategy)
        this.get${prop.nameWithUpperCase}().addAll(other.${prop.name});
#end ## if prop genericType
      } else {
        // nothing to copy
      }
    } else {
      this.$prop.name = other.$prop.name;
    }
#if($prop.contained)
    if(this.${prop.name}!=null) {
      this.${prop.name}.forEach((e) -> {
          #set($propertyToModifyValue = "e")
          #set($oppositeValue = "this")
          #set($codeIndentValue = "        ")
#parse("${VMF_TEMPLATE_PATH}impl/set-opposite-via-reflection.vm")
      });
    }
#end ## if contained
#else
//    if(deepCopy) {
//      if(other.${prop.name}!=null) {
//        this.set${prop.nameWithUpperCase}((${prop.typeName})other.${prop.name});
//      }
//    } else {
//      this.set${prop.nameWithUpperCase}(other.${prop.name});
//    }
#if($prop.type)
      // property type is a model type
      this.set${prop.nameWithUpperCase}(($prop.typeName)((VMFInternalInterface)other.${prop.name})._vmf_deepCopy(identityMap));
#else
      // property type is an external type (TODO implement cloning strategy)
      this.set${prop.nameWithUpperCase}(other.${prop.name});
#end ## if prop genericType
#end ## if collection
#end ## if containment typs
#end ## for-each property
   } // end copy constructor

   @Override
   public Object _vmf_deepCopy(java.util.IdentityHashMap<Object,Object> identityMap) {
      if(identityMap.containsKey(this)) {
        return (${type.implementation.typeName})identityMap.get(this);
      } else {
        ${type.implementation.typeName} clonedVal = new ${type.implementation.typeName}(this, true, identityMap);
        return clonedVal;
      }
   }

  @Override
  public Object clone() /*throws CloneNotSupportedException*/ {
    // http://stackoverflow.com/questions/12886036/deep-copying-a-graph-structure
    // http://softwareengineering.stackexchange.com/questions/228848/how-does-java-handle-cyclic-data-references-when-serializing-an-object
    // https://gist.github.com/kanrourou/47223bdaf481505d4c7e
    // http://www.programcreek.com/2012/12/leetcode-clone-graph-java/
    java.util.IdentityHashMap<Object,Object> identityMap =
      new java.util.IdentityHashMap<>();
    return _vmf_deepCopy(identityMap);
  }

  // ---------------------------- END CLONING ------------------------------
