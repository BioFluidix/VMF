#*
 * Copyright 2017-2019 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 * Copyright 2017-2019 Goethe Center for Scientific Computing, University Frankfurt. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 *#
#foreach( $prop in ${type.implementation.propertiesWithoutCollectionsBasedContainment} )
#if(${prop.propType}=="COLLECTION")##  if   (prop is collection type)
#elseif(${prop.readOnly} == true)  ##  elif (prop is read-only)
public $prop.setterDeclaration { throw new RuntimeException("Cannot set read-only property'${prop.name}'."); }
#else##-----------------------------## else (prop is collection type)
#if(${prop.containmentProperty})## if (containmentProperty)
#if(${prop.containmentInfo.withoutOpposite})## if (no opposite)
// ----------------------------------------
// - containment-prop:
//   -> prop is ref to contained object
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}  
//   -> opposite:      false, <none>
// ----------------------------------------
  @Override
  public $prop.setterDeclaration {

    // return early if identical value has been set
    if (this.__vmf_prop_$prop.name == $prop.name) {
      return;
    }
  } // end setterDeclaration (setter method)    
#else##--------------------------------------else (no opposite)
########################################################################################################################
#if(${prop.containmentInfo.containmentType}=="CONTAINED")## if (prop is contained)   
#if(${prop.containmentInfo.opposite.propType}=="COLLECTION")## if (opposite is collection)
// ----------------------------------------
// - containment-prop:
//   -> prop is ref to contained object
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}  
//   -> opposite:      true, ${prop.containmentInfo.opposite.typeName}.${prop.containmentInfo.opposite.name}
//      -> propType:   ${prop.containmentInfo.opposite.typeName}
//      -> collection: false
// ----------------------------------------
// FIXME: we cannot have a collection as parent container!
#else##-----------------------------------------------------## else (opposite is collection)
// ----------------------------------------
// - containment-prop:
//   -> prop is ref to contained object
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}  
//   -> opposite:      true, ${prop.containmentInfo.opposite.typeName}.${prop.containmentInfo.opposite.name}
//      -> propType:   ${prop.containmentInfo.opposite.typeName}
//      -> collection: false
// ----------------------------------------
  @Override
  public $prop.setterDeclaration {

    // return early if identical value has been set
    if (this.__vmf_prop_$prop.name == $prop.name) {
      return;
    }

    // ----------------------------------------
    // containment property: 
    // ----------------------------------------
    // -> this is a single contained property (child)
    // -> the opposite is a single container property (parent)
    // ----------------------------------------
  } // end setterDeclaration (setter method)    

#end##------------------------------------------------------## end (opposite is collection)
########################################################################################################################
#else##--------------------------------------------------## else (prop is contained)
#if(${prop.containmentInfo.opposite.propType}=="COLLECTION")## if (opposite is collection)
// ----------------------------------------
// - containment-prop:
//   -> prop is ref to container object
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}  
//   -> opposite:      true, ${prop.containmentInfo.opposite.typeName}.${prop.containmentInfo.opposite.name}
//      -> propType:   ${prop.containmentInfo.opposite.typeName}
//      -> collection: false
// ----------------------------------------
  @Override
  public $prop.setterDeclaration {

    // ----------------------------------------
    // containment property: 
    // ----------------------------------------
    // -> this is a single property
    // -> the opposite is a collection
    // ----------------------------------------

    // opposite is a collection type. we just need to add this to the
    // opposite collection which will handle the containment just fine
  } // end setterDeclaration (setter method)    

#else##-----------------------------------------------------## else (opposite is collection)
// ----------------------------------------
// - containment-prop:
//   -> prop is ref to container object
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}  
//   -> opposite:      true, ${prop.containmentInfo.opposite.typeName}.${prop.containmentInfo.opposite.name}
//      -> propType:   ${prop.containmentInfo.opposite.typeName}
//      -> collection: false
// ----------------------------------------
  @Override
  public $prop.setterDeclaration {

    // return early if identical value has been set
    if (this.__vmf_prop_$prop.name == $prop.name) {
      return;
    }

    // ----------------------------------------
    // set the new value
    // ----------------------------------------
    $prop.typeName oldValue = this.__vmf_prop_$prop.name;
    this.__vmf_prop_$prop.name = $prop.name;
    // ----------------------------------------
    }
  } // end setterDeclaration (setter method)    

#end##------------------------------------------------------## end (opposite is collection)
#end##---------------------------------------end  (no opposite)
########################################################################################################################
#end##---------------------------------------------------## end (prop is contained)
#else##----------------------------else (containmentProperty)
#if(${prop.crossRefProperty})##--------------if (crossref prop)
#if(${prop.referenceInfo.opposite.propType}=="COLLECTION")##---if (opposite is collection)
// ----------------------------------------
// - cross-ref:      
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}    
//   -> opposite:      true, ${prop.referenceInfo.opposite.typeName}.${prop.referenceInfo.opposite.name}
//      -> propType:   ${prop.referenceInfo.opposite.typeName}
//      -> collection: true
// ----------------------------------------
  @Override
  public $prop.setterDeclaration {

    // return early if identical value has been set
    if (this.__vmf_prop_$prop.name == $prop.name) {
      return;
    }

    // ----------------------------------------
    // store the old value ...
    // ----------------------------------------
    $prop.typeName oldValue = this.__vmf_prop_$prop.name;
    
  } // end setterDeclaration (setter method)    
#else##--------------------------------------------------##----else (opposite is collection)
// ----------------------------------------
// - cross-ref: 
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}      
//   -> opposite:      true, ${prop.referenceInfo.opposite.typeName}.${prop.referenceInfo.opposite.name}
//      -> propType:   ${prop.referenceInfo.opposite.typeName}
//      -> collection: false
// ----------------------------------------
  @Override
  public $prop.setterDeclaration {

    // return early if identical value has been set
    if (this.__vmf_prop_$prop.name == $prop.name) {
      return;
    }

    // ----------------------------------------
    // we are a cross-ref property and need to fire after updating the other prop to allow event propagation
    // fire property change event
    // ----------------------------------------


  } // end setterDeclaration (setter method)    
#end##---------------------------------------------------##----end (opposite is collection)
#else##--------------------------------------else (crossref prop)
// ----------------------------------------
// - normal prop:     
//   -> prop:
//      -> name:       ${prop.name}  
//      -> propType:   ${prop.typeName}     
//      -> collection: false, ${prop.propType}
//   -> opposite:      false, <none>
// ----------------------------------------
  @Override
  public $prop.setterDeclaration {

    // return early if identical value has been set
    if (this.__vmf_prop_$prop.name == $prop.name) {
      return;
    }

    // ----------------------------------------
    // set the new value
    // ----------------------------------------
    $prop.typeName oldValue = this.__vmf_prop_$prop.name;
    this.__vmf_prop_$prop.name = $prop.name;
    // ----------------------------------------

    // fire property changed event
    this._vmf_firePropertyChangeIfListenersArePresent("${oppositeRefProp.name}", oldValue, this.__vmf_prop_$prop.name);
    //this._vmf_firePropertyChangeIfListenersArePresent("${oppositeRefProp.name}", refOldVal, null, ${VMFPKG_INT}.ChangeInternal.CHANGE_TYPE_CROSS_REF);

  } // end setterDeclaration (setter method)    
#end##---------------------------------------end (crossref prop)
#end##-----------------------------end (containmentProperty)
#end##------------------------------## end  (prop is collection type)
#end## end for-each



#foreach( $prop in ${type.implementation.propertiesWithoutCollectionsBasedContainment} )
#if(${prop.propType}=="COLLECTION")##  if   (prop is collection type)
#elseif(${prop.readOnly} == true)  ##  elif (prop is read-only)
public $prop.setterDeclaration { throw new RuntimeException("Cannot set read-only property'${prop.name}'."); }
#else                              ##  else (prop is writable property)
@Override
public $prop.setterDeclaration {

  // return early if identical value has been set
  if (this.__vmf_prop_$prop.name == $prop.name) {
    return;
  }

  // ----------------------------------------
  // set the new value
  // ----------------------------------------
  $prop.typeName oldValue = this.__vmf_prop_$prop.name;
  this.__vmf_prop_$prop.name = $prop.name;
  // ----------------------------------------

  // ----------------------------------------
  // fire property changed event
  // ----------------------------------------
  this._vmf_firePropertyChangeIfListenersArePresent("${oppositeRefProp.name}", oldValue, this.__vmf_prop_$prop.name);
  //this._vmf_firePropertyChangeIfListenersArePresent("${oppositeRefProp.name}", refOldVal, null, ${VMFPKG_INT}.ChangeInternal.CHANGE_TYPE_CROSS_REF);
  // ----------------------------------------
} // end setterDeclaration (setter method) : $prop.setterDeclaration  
#end                               ##  end  (prop is writable property)
#end## end for-each property


public void _vmf_unregisterFromContainers() {
#foreach( $container in ${type.implementation.properties} ) 
#if(${container.containmentInfo.containmentType}=="CONTAINER" && !${container.containmentInfo.withoutOpposite})
   // UNREGISTERING from container: ${container.parent.typeName}.${container.name} : type: ${container.typeName}
   if(this.__vmf_prop_${container.name} != null) {
      __VMF_TYPE_${container.type.typeName}Impl container_internal = (__VMF_TYPE_${container.type.typeName}Impl)this.__vmf_prop_${container.name};
      
      // release 'this' from container property '${container.typeName}.${container.containmentInfo.opposite.name}'
      Object oldValue = container_internal.__vmf_get_prop_${container.containmentInfo.opposite.name}();
      if(oldValue != null) {
        container_internal.__vmf_set_prop_${container.containmentInfo.opposite.name}(null);
        container_internal._vmf_firePropertyChangeIfListenersArePresent("${container.containmentInfo.opposite.name}", oldValue, null);
      }

      // release container property '${container.name}' from this
      this.__vmf_prop_${container.name} = null;
      this._vmf_firePropertyChangeIfListenersArePresent("${container.name}", container_internal, null);
   }
#else##  no container
   // no container: ${container.name} : ${container.typeName}   
#end##   container 
#end## for-each container
}

#foreach( $prop in ${type.implementation.properties} )




@Override
{
  // return early if identical value has been set
  if (this.__vmf_prop_$prop.name == $prop.name) {
    return;
  }

  // ----------------------------------------
  // set the new value
  // ----------------------------------------
  $prop.typeName oldValue = this.__vmf_prop_$prop.name;
  this.__vmf_prop_$prop.name = $prop.name;
  // ----------------------------------------

  // ----------------------------------------
  // fire property changed event
  // ----------------------------------------
  this._vmf_firePropertyChangeIfListenersArePresent("${oppositeRefProp.name}", oldValue, this.__vmf_prop_$prop.name);
  //this._vmf_firePropertyChangeIfListenersArePresent("${oppositeRefProp.name}", refOldVal, null, ${VMFPKG_INT}.ChangeInternal.CHANGE_TYPE_CROSS_REF);
  // ----------------------------------------
} // end setterDeclaration (setter method) : $prop.setterDeclaration 
#end## end for-each property